#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

Adafruit_MPU6050 mpu;

/* Gesture thresholds (degrees) */
const float FORWARD_ENTER  = 12.0;
const float FORWARD_EXIT   = 10.0;
const float BACKWARD_ENTER = 18.0;
const float BACKWARD_EXIT  = 16.0;
const float SIDE_ENTER     = 20.0;
const float SIDE_EXIT      = 18.0;

/* Neutral offsets (degrees) */
float PITCH_OFFSET = -50.0;
float ROLL_OFFSET  = -10.0;

/* Tilt state */
String currentTilt = "Flat";
uint8_t tiltCode = 0;

/* BLE */
BLEServer* pServer;
BLECharacteristic* pCharacteristic;
bool deviceConnected = false;

#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcdefab-1234-1234-1234-abcdefabcdef"

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) {
    deviceConnected = true;
    Serial.println("Client connected");
  }
  void onDisconnect(BLEServer* pServer) {
    deviceConnected = false;
    Serial.println("Client disconnected");
    BLEDevice::startAdvertising();
  }
};

void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);

  /* Initialize IMU */
  if (!mpu.begin()) {
    Serial.println("MPU6050 not detected");
    while (1) delay(10);
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
  mpu.setGyroRange(MPU6050_RANGE_250_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  /* Initialize BLE */
  BLEDevice::init("ESP32_Tilt");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService* pService = pServer->createService(SERVICE_UUID);
  pCharacteristic = pService->createCharacteristic(
                      CHARACTERISTIC_UUID,
                      BLECharacteristic::PROPERTY_READ |
                      BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic->addDescriptor(new BLE2902());
  pService->start();
  BLEDevice::getAdvertising()->addServiceUUID(SERVICE_UUID);
  BLEDevice::startAdvertising();

  Serial.println("System ready");
}

void loop() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  /* Angle estimation */
  float pitch = atan2(-a.acceleration.x, sqrt(a.acceleration.y*a.acceleration.y + a.acceleration.z*a.acceleration.z)) * 180.0 / PI;
  float roll  = atan2(a.acceleration.y, a.acceleration.z) * 180.0 / PI;

  pitch += PITCH_OFFSET;
  roll  += ROLL_OFFSET;

  String newTilt = "Flat";

  /* Gesture classification (lateral priority) */
  if (roll > SIDE_ENTER)                  newTilt = "Right";
  else if (roll < -SIDE_ENTER)           newTilt = "Left";
  else if (pitch > FORWARD_ENTER)        newTilt = "Forward";
  else if (pitch < -BACKWARD_ENTER)      newTilt = "Backward";
  else if (abs(pitch) < FORWARD_EXIT &&
           abs(roll)  < SIDE_EXIT)       newTilt = "Flat";

  /* Update and transmit only when changed */
  if (newTilt != currentTilt) {
    currentTilt = newTilt;

    if      (currentTilt == "Flat")     tiltCode = 0;
    else if (currentTilt == "Forward")  tiltCode = 1;
    else if (currentTilt == "Backward") tiltCode = 2;
    else if (currentTilt == "Left")     tiltCode = 3;
    else if (currentTilt == "Right")    tiltCode = 4;

    if (deviceConnected) {
      pCharacteristic->setValue(&tiltCode, 1);
      pCharacteristic->notify();
    }

    Serial.print("Tilt: ");
    Serial.print(currentTilt);
    Serial.print(" | Code: ");
    Serial.println(tiltCode);
  }

  /* Debug output */
  Serial.print("Pitch: "); Serial.print(pitch);
  Serial.print(" | Roll: "); Serial.print(roll);
  Serial.print(" | State: "); Serial.println(currentTilt);

  delay(80);
}
